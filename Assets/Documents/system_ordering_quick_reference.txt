# ğŸ¯ No More Engine - System Ordering Quick Reference

## Current System Order (Top to Bottom)

```
ğŸ“¥ InputProcessingPhase
   â””â”€ PlayerInputMovementSystem

âš›ï¸ PhysicsPhase
   â”œâ”€ GravitySystem
   â”œâ”€ SimpleMovementSystem â† [After: Gravity] [Before: Collision]
   â”œâ”€ CollisionDetectionSystem â† [After: Movement] [Before: Response]
   â”œâ”€ CollisionResponseSystem â† [After: Detection] [Before: Transform]
   â””â”€ SimEntityTransformSystem â† [OrderLast]

ğŸ® GameplayPhase
   â””â”€ (empty - future systems here)

ğŸ§¹ CleanupPhase
   â””â”€ (empty - future cleanup here)
```

## Copy-Paste Attributes

```csharp
// For Input Systems
[UpdateInGroup(typeof(InputProcessingPhase))]

// For Physics Systems  
[UpdateInGroup(typeof(PhysicsPhase))]
[UpdateAfter(typeof(PreviousSystem))]
[UpdateBefore(typeof(NextSystem))]

// For Gameplay Systems
[UpdateInGroup(typeof(GameplayPhase))]

// For Cleanup Systems
[UpdateInGroup(typeof(CleanupPhase))]
```

## Decision Tree for New Systems

```
Does it process player input?
  YES â†’ InputProcessingPhase
  NO â†“

Does it move entities or handle physics?
  YES â†’ PhysicsPhase
  NO â†“

Does it handle game logic (health, damage, spawning)?
  YES â†’ GameplayPhase
  NO â†“

Does it clean up or destroy entities?
  YES â†’ CleanupPhase
  NO â†’ Reconsider what phase it belongs to
```

## âš ï¸ Remember

- âŒ Never use multiple `[UpdateInGroup]` on one system
- âœ… Always add time requirement: `state.RequireForUpdate<SimulationTimeComponent>()`
- âœ… Be explicit with `[UpdateAfter]` and `[UpdateBefore]`
- âœ… Test with `DeterminismTestTool` after adding systems

## ğŸš€ Next Systems to Add

1. **JumpSystem** â†’ PhysicsPhase (after Input, before Gravity)
2. **GameplaySpawnerSystem** â†’ GameplayPhase (first)
3. **DamageSystem** â†’ GameplayPhase (after Spawner)
4. **DestroyEntitySystem** â†’ CleanupPhase (last)